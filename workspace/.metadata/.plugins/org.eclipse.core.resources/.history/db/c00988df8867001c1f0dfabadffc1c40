package io;

import model.*;

import java.awt.Point;
import java.awt.Shape;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.Iterator;
import java.util.Vector;

import view.VGraphic;
/**
 * each node is written to the tex file and translated therefore
 * x - offset to get rid of the free space left of the graph
 * maxy - y to invert y (no offset substractiion needed, because 0 is max and max.y - offset.y is the maximum to be reached
 * @author ronny
 *
 */
public class MyLaTeXPictureWriter {

	private final static String NL = "\r\n";
	private final static double LINESPPT = 3.0d;
	VGraphic vgc;
	VGraph vg;
	GeneralPreferences gp;
	Point max,offset;
	private int width;
	double sizeppt; //Groeße die ein punkt/pixel ind er Grafik dann in mm aufm Papier hat
	public MyLaTeXPictureWriter(VGraphic a_picture, int w)
	{
		vgc = a_picture;
		vg = vgc.getVGraph();
		gp = GeneralPreferences.getInstance();
		width = w;
	}
	
	//General
	
	private void writeHeader(OutputStreamWriter s) throws IOException
	{
		sizeppt = (double)width/(double)(vg.getMaxPoint(vgc.getGraphics()).x-vg.getMinPoint(vgc.getGraphics()).x);
		s.write("%Exported Graph by Gravel"+NL+"%"+NL+"%to use in your own LaTeX-Document copy the figure into your file"+NL);
		s.write("%"+NL+"%This Document is minimized in its usage of packages"+NL);
		s.write(NL+"\\documentclass{scrartcl}"+NL);
		s.write("\\usepackage{epic}"+NL);
		s.write("\\usepackage{eepic}"+NL);
		//s.write("\\setpapersize{A4}");
		s.write("\\begin{document}");
		s.write(NL+"\t%"+NL+"\t%Copy this Part into your Document"+NL+"\t%");
		//Compute the size and offset
		offset = vg.getMinPoint(vgc.getGraphics());
		max = vg.getMaxPoint(vgc.getGraphics());
		int x = max.x - offset.x; //Breite
		int y = max.y - offset.y; //Hoehe
		s.write(NL+"\t\\begin{figure}"+NL+"\t\\centering");				
		s.write(NL+"\t%If you change this size of the graphic the textsize won't change, so the letters appear bigger or smaller than with the exportet size."+NL+"\t%For changing size, a new export is reccomended.");
		s.write(NL+"\\setlength{\\unitlength}{"+sizeppt+"mm}");
		s.write(NL+"\t\\begin{picture}("+x+","+(y+1)+")(0,0)"+NL); //+kein Offset ist testweise
	}

	private void writeFooter(OutputStreamWriter s, String name) throws IOException
	{
		s.write(NL+"\t\\end{picture}"+NL);
		s.write(NL+"\t\t\\caption{"+name+"}"+NL);
		s.write("\t\\end{figure}");
		s.write(NL+"\t%"+NL+"\t%End of the Graph"+NL+"\t%");
		s.write(NL+"\\end{document}"+NL);
	}
	
	//Visual
	
	private void writeNodes(OutputStreamWriter s) throws IOException
	{
	    //Nodes
	    Iterator<VNode> nodeiter = vg.getNodeIterator();
	    while (nodeiter.hasNext())
	    {
	    	VNode actual = nodeiter.next();
	    	Point drawpoint = new Point(actual.getPosition().x-offset.x,max.y - actual.getPosition().y);
	    	s.write(drawCircle(drawpoint,actual.getSize()));
	    	if (actual.isNameVisible()) //draw name
			{	
				//mittelpunkt des Textes
				int x = drawpoint.x + Math.round((float)actual.getNameDistance()*(float)Math.cos(Math.toRadians((double)actual.getNameRotation())));
				//Invert y
				int y = drawpoint.y + Math.round((float)actual.getNameDistance()*(float)Math.sin(Math.toRadians((double)actual.getNameRotation())));
				double tsize = Math.round((double)actual.getNameSize()*sizeppt*((double)1000))/1000;
				s.write(NL+"\t\t\\put("+x+","+y+"){\\makebox(0,0){\\fontsize{"+tsize+"mm}{10pt}\\selectfont "+formname(vg.getNodeName(actual.index))+"}}");
			}
		}
	}
	private String formname(String ur)
	{
		ur = replace(ur,"#","\\#");
		return "$"+ur+"$";
	}
	/**
	 * Einfache SubStringersetzung
	 * @param in Eingabe
	 * @param remove entfernen und 
	 * @param replace ersetzen durch diesen
	 * @return
	 */
	public static String replace(String in,String remove, String replace) 
	{
		if (in==null || remove==null || remove.length()==0) return in;
		StringBuffer sb = new StringBuffer();
		int oldIndex = 0;
		int newIndex = 0;
		int remLength = remove.length();
		while ( (newIndex = in.indexOf(remove,oldIndex)) > -1) 
		{
				//copy from last to new appearance
				sb.append(in.substring(oldIndex,newIndex));
				sb.append(replace);
				//set old index to end of last apperance.
				oldIndex = newIndex + remLength;
		}
		int inLength = in.length();
		//add part after last appearance of string to remove
		if(oldIndex<inLength) sb.append(in.substring(oldIndex,inLength));
		return sb.toString();
	}
	private void writeEdges(OutputStreamWriter s) throws IOException
	{
	       //Nodes
	    	Iterator<VEdge> edgeiter = vg.getEdgeIterator();
	    	while (edgeiter.hasNext())
	    	{
	    	   VEdge actual = edgeiter.next();
	    	   Vector<Integer> values = vg.getEdgeProperties(actual.index);
	    	   int start = values.elementAt(MGraph.EDGESTARTINDEX);
	    	   int ende = values.elementAt(MGraph.EDGEENDINDEX);
	    	   //not needed int value = values.elementAt(MGraph.EDGEVALUE);
			   //Mittlere Linie der Kante...immer Zeichnen
			   s.write(NL+drawOneEdgeLine(actual,start,ende,0.0d));
			   if (actual.getWidth()>1)
				   s.write("\\thicklines");
			   for (int i=0; i<(actual.getWidth()-1)*(new Double(Math.round(LINESPPT/2))).intValue(); i++)
			   {
				   //One Side
				   s.write(drawOneEdgeLine(actual,start,ende,(double)i));
				   //Other Side
				   s.write(drawOneEdgeLine(actual,start,ende,-1.0d*(double)i));				   
			   }
	    	   //Nun die Liniendicke aufbauen
	    	  //Nun noch den Pfeil
			  s.write(drawArrow(actual,start,ende));
	       }//End while edges.hasNext()
	}
	/** DRaw an Edge from Start to ende with the offset movx, movy
	 * 
	 * @param actual
	 * @param start
	 * @param ende
	 * @param movx
	 * @param movy
	 * @return The Picture Enviroment String for the drawing
	 */
	private String drawOneEdgeLine(VEdge actual,int start, int ende, double distancefromline)
	{
		String s ="";
    	double[] coords = new double[2];
    	double x = 0.0, y = 0.0, lastx=0.0, lasty = 0.0;
		GeneralPath p = actual.getPath(vg.getNode(start).getPosition(),vg.getNode(ende).getPosition(),1.0f); //no zoom on check!
		PathIterator path = p.getPathIterator(null, 0.001); 
		// 0.005 = the flatness; reduce if result is not accurate enough!
		while( !path.isDone() ) 
		{
		   int type = path.currentSegment(coords);
		    x = coords[0]; y = coords[1];
		    if ((x!=lastx)||(y!=lasty))
		    {
		    	Point2D.Double dir = new Point2D.Double(x - lastx,y-lasty);
		    	double dlength = LINESPPT*dir.distance(new Point2D.Double(0,0));
				Point.Double orth_n_h = new Point.Double ((double)dir.y/dlength,-(double)dir.x/dlength);
		    	double movx = orth_n_h.x*distancefromline;
		    	double movy = orth_n_h.y*distancefromline;
				if (type==PathIterator.SEG_MOVETO)
					s +=(NL+"\t\\path("+(x+movx-offset.x)+","+(max.y-y+movy)+")");	   		    		
		    	else if (type==PathIterator.SEG_LINETO)	
		    		s +=("("+(x+movx-offset.x)+","+(max.y-y+movy)+")");
		   }
		   lastx = x; lasty = y;
		   path.next();
		 }
		return s;
	}
	
	/**
	 * 
	 * @param actual
	 * @param start
	 * @param ende
	 * @return
	 */
	private String drawArrow(VEdge actual, int start, int ende)
	{
		double[] coords = new double[2];
		double x = 0.0, y = 0.0;
		Point2D.Double arrowhead = new Point2D.Double(),line1start = new Point2D.Double(),line1 = new Point2D.Double(),line2start = new Point2D.Double(),line2 = new Point2D.Double();
		String s = "";
		if (actual.getWidth()>1) //Dann wurde die kante mit Thicklines verbreitert -> wiederzurück zu thin
			s += NL+"\\thinlines";
		if (vg.isDirected())
		{
		  	Shape arrow = actual.getArrowShape(vg.getNode(start).getPosition(),vg.getNode(ende).getPosition(),Math.round(vg.getNode(start).getSize()/2),Math.round(vg.getNode(ende).getSize()/2),1.0f);
		  	PathIterator path = arrow.getPathIterator(null, 0.001);
		  	int i=0;
		    while( !path.isDone() ) 
		      {
		      int type = path.currentSegment(coords);
		    	x = coords[0]; y = coords[1];
		    	if (type==PathIterator.SEG_MOVETO)
		    	{
		    		s += NL+"\\path("+(x-offset.x)+","+(max.y-y)+")";
		    		arrowhead = new Point2D.Double(x-offset.x,max.y-y);
		    	}
		    	else if (type==PathIterator.SEG_LINETO)	
		    	{
		    		s += "("+(x-offset.x)+","+(max.y-y)+")";
		    		if (i==0)
		    			line1start = new Point2D.Double(x-offset.x,max.y-y);
		    		else if (i==1)
		    		{
		    			line2start = new Point2D.Double(x-offset.x,max.y-y);
		    			line1 = new Point2D.Double(line2start.x-line1start.x,line2start.y-line1start.y);
		    		}
		    		else if (i==2)
		    		{
		    			line2 = new Point2D.Double((double)(x-offset.x)-line2start.x,(double)(max.y-y) - line2start.y);		    			
		    		}
		    		i++;	
		    	}
		    	path.next();
		    }
		    //How many lines on one of the two parts ?
		    int maxcount = (new Double (Math.round(actual.getArrowSize()*LINESPPT/sizeppt))).intValue();
		    //Shorten the direction vectors to a 1/maxcount th of the length
		    line1.x = line1.x/maxcount; line1.y = line1.y/maxcount;
		    line2.x = line2.x/maxcount; line2.y = line2.y/maxcount;
		    s += "\\path("+arrowhead.x+","+arrowhead.y+")("+line2start.x+","+line2start.y+")"; //Middle line in Thick
		    for (int j=1; j<maxcount; j++)
		    {
		    	s += "\\path("+arrowhead.x+","+arrowhead.y+")("+(line1start.x+line1.x*(double)j)+","+(line1start.y+line1.y*(double)j)+")"; //Middle line in Thick
		    	s += "\\path("+arrowhead.x+","+arrowhead.y+")("+(line2start.x+line2.x*(double)j)+","+(line2start.y+line2.y*(double)j)+")"; //Middle line in Thick
		    }
		}
		return s;
	}
	private void writeSubSets(OutputStreamWriter s) throws IOException
	{
	       //SubSets - Umrandungen hier einbauen
	}
	public String saveToFile(File f)
	{
		if (!f.exists())
			try{
				f.createNewFile();
			}
			catch (Exception e)
			{
				return "Creation_Error : "+e.getMessage();
			}
		
		try {        
		vgc.setZoomEnabled(false);
	       OutputStream fout= new FileOutputStream(f);
	       OutputStream bout= new BufferedOutputStream(fout);
	       OutputStreamWriter out = new OutputStreamWriter(bout, "UTF8");
	       writeHeader(out);
	       writeEdges(out);
	       writeNodes(out);
	       writeSubSets(out);
	       writeFooter(out,"Gravel Graphen-Export '"+f.getName()+"'");
	       out.flush();  // Don't forget to flush!
	       out.close();
	       vgc.setZoomEnabled(true);
		}
		catch (Exception e)
		{
			return "Fehler beim schreiben: "+e;
		}
		return "";
	}
	private String drawCircle(Point m, int s)
	{	
		return NL+"\\put("+m.x+","+m.y+"){\\circle*{"+s+"}}";
	}
}
